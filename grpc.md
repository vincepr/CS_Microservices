# part 8 - gRPC

In our usecase we want to use Grpc on the CommandsService startup to reach out to PlatformService and Sync up their states.
- PlatformService runs on a InMemoryDb. So while it will get and add new Platforms created while it is running. It has no knowledge on the `starting state`. 

## Notes on gRPC
- google Rmove Procedure Call
- uses HTTP2 to transport binary messages. (faster compared to json)
    - so it requires TLS - HTTPS! 
- Relies on **"Protocol Buffers"** (aka Protobuf) - these define the contract between the endpoints
    - `.proto` file has the type information of the data
- gRPC is used mostly for Server to Server communication

## Https workarround
- since setting up https inside our cluster is quite a bit of work we explicitly only use http inside our cluster
- at the end of our `platforms-depl.yaml` we add another Port to the ClusterIpService
```yaml
    - name: platformgrpc
        protocol: TCP
        port: 666
        targetPort: 666
```
- and apply it with `kubectl apply -f K8S/platforms-depl.yaml`

- we explicitly tell gRPC to only use http (otherwise it would default to https) in `appsettings.Production.json`
```json
  "Kestrel": {
    "Endpoints": {
      "Grpc": {
        "Protocols": "Https2",
        "Url": "http://platforms-clusterip-srv:666"
      },
      "webApi": {
        "Protocols": "Http1",
        "Url": "http://platforms-clusterip-srv:666"
      }
    }
  }
```
## Add packages 
- for our PlatformService we add:
```
dotnet add package Grpc.AspNetCore
```
- for our CommandsService we add:
```
dotnet add package Grpc.Tools
dotnet add package Grpc.Net.Client
dotnet add package Google.Protobuf
```
## Create the proto-file
- in `PlatformsService/Protos/platforms.proto` we define the contract and what can get passed on the grpc-connection:

```proto
syntax = "proto3";

// just the top level namespace of this project, gets used for the autogenerated code:
option csharp_namespace = "PlatformService";

// we define the service/endpoint
service GrpcPlatform {
    rpc GetAllPlatforms(GetAllRequests) returns (PlatformResponse);
}

// this endpoint's input has no parameters but we still have to name it:
message GetAllRequests {}

// We define the shape of data that gets passed back (we wanna pass an array of those)
message GrpcPlatformModel {
    int32 platformId = 1;   // the 1 is not the value but the 'index' or position of where in GrpPlatformModel this gets placed
    string name = 2;
    string publisher = 3;
}

// an array of the above 'objects'
message PlatformResponse {
    repeated GrpcPlatformModel platform = 1;
}
```

- `PlatformService/PlatformService.csproj` we add an Item group. This will tell the project the path to the proto-file and what type were running as (server/client)
```xml
  <ItemGroup>
    <Protobuf Include="Protos/platforms.proto" GrpcServices="Server" />
  </ItemGroup>
```
- we dotnet build the Platformservice and if everything worked, we should be able to look into the autogenerated code: `PlatformService/obj/Debug/net7.0/Protos/Platforms.cs` and `PlatformService/obj/Debug/net7.0/Protos/PlatformsGrpc.cs`

## Code in PlatformService
- we add grpc for dependency injection in our `PlatformService/Program.cs` and add 
```csharp
builder.Services.AddGrpc();
// ...
app.MapControllers();   // this maps all our Controllers by default
app.MapGrpcService<GrpcPlatformService>();  // the grpcService we have to Add manually
// we (this is optinal) serve the protobuf file to the client, so they could infer everyhing from it:
app.MapGet(
    "/protos/platforms.proto",
    async context => {
        await context.Response.WriteAsync(File.ReadAllText("Protos/platforms.proto"));
    }
);
```
- we add a mapping to the grpc model in `PlatformService/Profiles/PlatformsProfile.cs`
```csharp
// mapping for gRPC:
CreateMap<Platform, GrpcPlatformModel>()
    // even platformId is camelcase in .proto the generated one gets 'csharped' to PlatformId
    .ForMember(dest => dest.PlatformId, opt => opt.MapFrom(src => src.Id))
    // the other ForMembers would get inferred (because same name) but we do it just to show it more clear
    .ForMember(dest => dest.Name, opt => opt.MapFrom(src => src.Name))
    .ForMember(dest => dest.Publisher, opt => opt.MapFrom(src => src.Publisher));
```
- `PlatformService/SyncDataService/Grpc/GrpcPlatformService.cs`

```csharp
public class GrpcPlatformService : GrpcPlatform.GrpcPlatformBase {
    private readonly IPlatformRepo _repository;
    private readonly IMapper _mapper;

    public GrpcPlatformService(IPlatformRepo repository, IMapper mapper) {
        _repository = repository;
        _mapper = mapper;
    }

    public override Task<PlatformResponse> GetAllPlatforms(GetAllRequests request, ServerCallContext context) {
        var response = new PlatformResponse();
        var platforms = _repository.GetPlatforms();
        foreach (var p in platforms) {
            // map from our.Platform -> grpc.Platfrom and add those to grpc.Response
            response.Platform.Add(_mapper.Map<GrpcPlatformModel>(p));
        }
        return Task.FromResult(response);
    }
}
```